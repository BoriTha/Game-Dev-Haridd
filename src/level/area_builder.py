"""
Area Builder - Enhanced area system integration for procedural levels

This module provides enhanced area building that integrates with the special
rooms and areas generated by the enhanced generation algorithms.
"""

from typing import Dict, List, Tuple, Any, Optional
import random

from .area_system import Area, AreaMap, AreaType, build_default_areas, _is_walkable_tile, _expand_walkable_area, _find_nearest_walkable_area
from .terrain_system import TerrainTypeRegistry, TerrainBaseType


def build_enhanced_areas(
    level_data: Dict[str, Any],
    terrain_grid: List[List[str]],
    level_type: str = "dungeon"
) -> AreaMap:
    """
    Build comprehensive AreaMap for generated levels

    Args:
        level_data: Level data from generation algorithms
        terrain_grid: Terrain type grid
        level_type: Type of level (dungeon, cave, outdoor, hybrid)

    Returns:
        Complete AreaMap with all required area types
    """
    # Start with default areas (includes an initial PLAYER_SPAWN region)
    area_map = build_default_areas(level_data, terrain_grid)

    if level_type == "dungeon":
        area_map = _add_dungeon_areas(area_map, level_data, terrain_grid)
    elif level_type == "cave":
        area_map = _add_cave_areas(area_map, level_data, terrain_grid)
    elif level_type == "outdoor":
        area_map = _add_outdoor_areas(area_map, level_data, terrain_grid)
    elif level_type == "hybrid":
        area_map = _add_hybrid_areas(area_map, level_data, terrain_grid)

    # Normalize PLAYER_SPAWN areas before adding any fallbacks:
    # - ensure exactly one authoritative PLAYER_SPAWN zone
    # - prefer the area that contains the primary spawn point when present
    # - otherwise prefer the lowest (visually grounded) PLAYER_SPAWN band
    area_map = _dedupe_player_spawn_areas(area_map, level_data)

    # Ensure we have all critical area types (may add a PLAYER_SPAWN only if none exist)
    area_map = _ensure_critical_areas(area_map, level_data, terrain_grid)

    # Validate area coordinates
    validation_issues = _validate_area_coordinates(area_map, terrain_grid)
    # Note: Validation issues are handled internally, no need to spam console

    return area_map


def _add_dungeon_areas(
    area_map: AreaMap,
    level_data: Dict[str, Any],
    terrain_grid: List[List[str]]
) -> AreaMap:
    """Add areas specific to dungeon levels"""

    special_rooms = level_data.get('special_rooms', {})
    height = len(terrain_grid)
    width = len(terrain_grid[0]) if height > 0 else 0
    area_id_counter = len(area_map.areas) + 1

    # Add areas based on special rooms
    if 'spawn' in special_rooms:
        room = special_rooms['spawn']
        # Find actual walkable bounds within the room
        walkable_bounds = _find_walkable_area_bounds(room, terrain_grid, width, height)
        if walkable_bounds and walkable_bounds['width'] > 0 and walkable_bounds['height'] > 0:
            # Snap Y so area visually hugs platform/floor instead of floating one tile above
            walkable_bounds['y'] = _snap_area_vertically_to_platform(
                walkable_bounds['y'], terrain_grid, width, height
            )
            area_map.add_area(Area(
                id=f"player_spawn_room_{area_id_counter}",
                type=AreaType.PLAYER_SPAWN,
                x=walkable_bounds['x'],
                y=walkable_bounds['y'],
                width=walkable_bounds['width'],
                height=walkable_bounds['height'],
                attributes={"room_type": "spawn"}
            ))
            area_id_counter += 1
        else:
            # Fallback: find nearest walkable area to room center
            center_x, center_y = room.x + room.width // 2, room.y + room.height // 2
            nearest_walkable = _find_nearest_walkable_area(center_x, center_y, terrain_grid, width, height)
            if nearest_walkable:
                area_map.add_area(Area(
                    id=f"player_spawn_fallback_{area_id_counter}",
                    type=AreaType.PLAYER_SPAWN,
                    x=nearest_walkable['x'],
                    y=nearest_walkable['y'],
                    width=nearest_walkable['width'],
                    height=nearest_walkable['height'],
                    attributes={"room_type": "spawn_fallback"}
                ))
                area_id_counter += 1

    if 'portal' in special_rooms:
        room = special_rooms['portal']
        # Find actual walkable bounds within the room
        walkable_bounds = _find_walkable_area_bounds(room, terrain_grid, width, height)
        if walkable_bounds and walkable_bounds['width'] > 0 and walkable_bounds['height'] > 0:
            walkable_bounds['y'] = _snap_area_vertically_to_platform(
                walkable_bounds['y'], terrain_grid, width, height
            )
            area_map.add_area(Area(
                id=f"portal_room_{area_id_counter}",
                type=AreaType.PORTAL_ZONE,
                x=walkable_bounds['x'],
                y=walkable_bounds['y'],
                width=walkable_bounds['width'],
                height=walkable_bounds['height'],
                attributes={"room_type": "portal"}
            ))
            area_id_counter += 1
        else:
            # Fallback: find nearest walkable area to room center
            center_x, center_y = room.x + room.width // 2, room.y + room.height // 2
            nearest_walkable = _find_nearest_walkable_area(center_x, center_y, terrain_grid, width, height)
            if nearest_walkable:
                area_map.add_area(Area(
                    id=f"portal_fallback_{area_id_counter}",
                    type=AreaType.PORTAL_ZONE,
                    x=nearest_walkable['x'],
                    y=nearest_walkable['y'],
                    width=nearest_walkable['width'],
                    height=nearest_walkable['height'],
                    attributes={"room_type": "portal_fallback"}
                ))
                area_id_counter += 1

    if 'merchant' in special_rooms:
        room = special_rooms['merchant']
        # Find actual walkable bounds within the room
        walkable_bounds = _find_walkable_area_bounds(room, terrain_grid, width, height)

        
        if walkable_bounds and walkable_bounds['width'] > 0 and walkable_bounds['height'] > 0:
            # Build a supported band area: every tile row fully supported by platform/floor,
            # height clamped between 3 and 6 tiles when possible (per design).
            supported_area = _build_supported_band_area(
                base_id=f"merchant_room_{area_id_counter}",
                area_type=AreaType.MERCHANT_AREA,
                bounds=walkable_bounds,
                terrain_grid=terrain_grid,
                min_height=3,
                max_height=6,
            )

            if supported_area:
                supported_area.attributes["room_type"] = "merchant"
                area_map.add_area(supported_area)
                area_id_counter += 1
            # Fallback: find nearest walkable area to room center
            center_x, center_y = room.x + room.width // 2, room.y + room.height // 2
            nearest_walkable = _find_nearest_walkable_area(center_x, center_y, terrain_grid, width, height)
            if nearest_walkable:
                # Try to build supported area from nearest walkable
                supported_area = _build_supported_band_area(
                    base_id=f"merchant_fallback_{area_id_counter}",
                    area_type=AreaType.MERCHANT_AREA,
                    bounds=nearest_walkable,
                    terrain_grid=terrain_grid,
                    min_height=3,
                    max_height=6,
                )
                if supported_area:
                    supported_area.attributes["room_type"] = "merchant_fallback"
                    area_map.add_area(supported_area)
                    area_id_counter += 1

    # Add enemy spawn areas in regular rooms
    rooms = level_data.get('rooms', [])
    for i, room in enumerate(rooms):
        if room not in special_rooms.values() and room.width >= 4 and room.height >= 4:
            # Check if room is mostly clear
            if _is_room_clear(room, terrain_grid, width, height):
                # Get valid bounds that exclude walls
                valid_bounds = _get_valid_area_bounds(room, terrain_grid, width, height)

                # Snap Y for enemy areas so colored areas align with platforms
                valid_bounds['y'] = _snap_area_vertically_to_platform(
                    valid_bounds['y'], terrain_grid, width, height
                )

                # Only create area if we have enough valid space AND has walkable tiles
                walkable_bounds = _find_walkable_area_bounds(room, terrain_grid, width, height)
                if valid_bounds['width'] >= 3 and valid_bounds['height'] >= 3 and walkable_bounds:
                    # Determine if ground or flying enemy area
                    if room.height > 6 or room.width > 6:
                        # Large room - flying enemies (can be in air spaces)
                        area_map.add_area(Area(
                            id=f"flying_enemy_spawn_{area_id_counter}",
                            type=AreaType.FLYING_ENEMY_SPAWN,
                            x=valid_bounds['x'],
                            y=valid_bounds['y'],
                            width=valid_bounds['width'],
                            height=valid_bounds['height'],
                            attributes={"room_type": "enemy_area", "enemy_type": "flying"}
                        ))
                    else:
                        # Small/medium room - ground enemies (need walkable tiles)
                        # Use walkable bounds for ground enemies
                        if walkable_bounds['width'] >= 2 and walkable_bounds['height'] >= 2:
                            area_map.add_area(Area(
                                id=f"ground_enemy_spawn_{area_id_counter}",
                                type=AreaType.GROUND_ENEMY_SPAWN,
                                x=walkable_bounds['x'],
                                y=walkable_bounds['y'],
                                width=walkable_bounds['width'],
                                height=walkable_bounds['height'],
                                attributes={"room_type": "enemy_area", "enemy_type": "ground"}
                            ))
                    area_id_counter += 1

    return area_map


def _add_cave_areas(
    area_map: AreaMap,
    level_data: Dict[str, Any],
    terrain_grid: List[List[str]]
) -> AreaMap:
    """Add areas specific to cave levels"""

    special_areas = level_data.get('special_areas', {})
    height = len(terrain_grid)
    width = len(terrain_grid[0]) if height > 0 else 0
    area_id_counter = len(area_map.areas) + 1

    # Create areas from cave chambers
    if 'spawn' in special_areas:
        tiles = special_areas['spawn']
        if tiles:
            bounds = _get_area_bounds(tiles)
            area_map.add_area(Area(
                id=f"cave_spawn_area_{area_id_counter}",
                type=AreaType.PLAYER_SPAWN,
                x=bounds['x'],
                y=bounds['y'],
                width=min(bounds['width'], width - bounds['x']),
                height=min(bounds['height'], height - bounds['y']),
                attributes={"cave_chamber": "spawn"}
            ))
            area_id_counter += 1

    if 'portal' in special_areas:
        tiles = special_areas['portal']
        if tiles:
            bounds = _get_area_bounds(tiles)
            # Ensure minimum 3x3 for portal
            pw = max(3, bounds['width'])
            ph = max(3, bounds['height'])
            px = min(bounds['x'], width - pw)
            py = min(bounds['y'], height - ph)
            area_map.add_area(Area(
                id=f"cave_portal_area_{area_id_counter}",
                type=AreaType.PORTAL_ZONE,
                x=px,
                y=py,
                width=min(pw, width - px),
                height=min(ph, height - py),
                attributes={"cave_chamber": "portal"}
            ))
            area_id_counter += 1

    # Add merchant area if specified
    if 'merchant' in special_areas and special_areas['merchant']:
        tiles = special_areas['merchant']
        bounds = _get_area_bounds(tiles)
        area_map.add_area(Area(
            id=f"cave_merchant_area_{area_id_counter}",
            type=AreaType.MERCHANT_AREA,
            x=bounds['x'],
            y=bounds['y'],
            width=min(bounds['width'], width - bounds['x']),
            height=min(bounds['height'], height - bounds['y']),
            attributes={"cave_chamber": "merchant"}
        ))
        area_id_counter += 1

    # Find areas for ground and flying enemies
    grid = level_data.get('grid', [])
    if grid:
        # Ground enemy areas - wider passages
        ground_areas = _find_wide_passages(grid, min_width=3)
        for i, area in enumerate(ground_areas[:5]):  # Limit to 5 areas
            area_map.add_area(Area(
                id=f"cave_ground_enemy_{area_id_counter}",
                type=AreaType.GROUND_ENEMY_SPAWN,
                x=area['x'],
                y=area['y'],
                width=min(area['width'], width - area['x']),
                height=min(area['height'], height - area['y']),
                attributes={"cave_feature": "passage"}
            ))
            area_id_counter += 1

        # Flying enemy areas - large chambers
        if 'spawn' in special_areas:
            spawn_center = _get_area_center(special_areas['spawn'])
            for chamber_name, tiles in special_areas.items():
                if chamber_name not in ['spawn', 'portal', 'merchant'] and len(tiles) > 30:
                    bounds = _get_area_bounds(tiles)
                    area_map.add_area(Area(
                        id=f"cave_flying_enemy_{area_id_counter}",
                        type=AreaType.FLYING_ENEMY_SPAWN,
                        x=bounds['x'],
                        y=bounds['y'],
                        width=min(bounds['width'], width - bounds['x']),
                        height=min(bounds['height'], height - bounds['y']),
                        attributes={"cave_feature": "chamber"}
                    ))
                    area_id_counter += 1

    return area_map


def _add_outdoor_areas(
    area_map: AreaMap,
    level_data: Dict[str, Any],
    terrain_grid: List[List[str]]
) -> AreaMap:
    """Add areas specific to outdoor levels"""

    clearings = level_data.get('clearings', [])
    height = len(terrain_grid)
    width = len(terrain_grid[0]) if height > 0 else 0
    area_id_counter = len(area_map.areas) + 1

    # Sort clearings by size
    clearings.sort(key=lambda r: r.width * r.height, reverse=True)

    # Largest clearing - spawn and merchant
    if clearings:
        spawn_clearing = clearings[0]
        # Get valid bounds that exclude walls
        valid_bounds = _get_valid_area_bounds(spawn_clearing, terrain_grid, width, height)
        valid_bounds['y'] = _snap_area_vertically_to_platform(
            valid_bounds['y'], terrain_grid, width, height
        )

        if valid_bounds['width'] >= 3 and valid_bounds['height'] >= 3:
            area_map.add_area(Area(
                id=f"outdoor_spawn_{area_id_counter}",
                type=AreaType.PLAYER_SPAWN,
                x=valid_bounds['x'],
                y=valid_bounds['y'],
                width=valid_bounds['width'],
                height=valid_bounds['height'],
                attributes={"clearing_type": "main"}
            ))
            area_id_counter += 1

        # Add merchant area in same clearing (different corner)
        if spawn_clearing.width >= 6 and spawn_clearing.height >= 6:
            area_map.add_area(Area(
                id=f"outdoor_merchant_{area_id_counter}",
                type=AreaType.MERCHANT_AREA,
                x=spawn_clearing.x + spawn_clearing.width - 4,
                y=spawn_clearing.y + spawn_clearing.height - 3,
                width=min(3, width - (spawn_clearing.x + spawn_clearing.width - 4)),
                height=min(2, height - (spawn_clearing.y + spawn_clearing.height - 3)),
                attributes={"clearing_type": "merchant"}
            ))
            area_id_counter += 1

    # Second largest clearing - portal
    if len(clearings) > 1:
        portal_clearing = clearings[1]
        # Ensure 3x3 minimum
        pw = max(3, min(portal_clearing.width, 5))
        ph = max(3, min(portal_clearing.height, 5))
        area_map.add_area(Area(
            id=f"outdoor_portal_{area_id_counter}",
            type=AreaType.PORTAL_ZONE,
            x=portal_clearing.x + (portal_clearing.width - pw) // 2,
            y=portal_clearing.y + (portal_clearing.height - ph) // 2,
            width=min(pw, width - (portal_clearing.x + (portal_clearing.width - pw) // 2)),
            height=min(ph, height - (portal_clearing.y + (portal_clearing.height - ph) // 2)),
            attributes={"clearing_type": "portal"}
        ))
        area_id_counter += 1

    # Other clearings - enemy spawn areas
    for clearing in clearings[2:7]:  # Up to 5 enemy clearings
        if clearing.width * clearing.height >= 15:
            # Get valid bounds that exclude walls
            valid_bounds = _get_valid_area_bounds(clearing, terrain_grid, width, height)
            valid_bounds['y'] = _snap_area_vertically_to_platform(
                valid_bounds['y'], terrain_grid, width, height
            )

            if valid_bounds['width'] >= 3 and valid_bounds['height'] >= 3:
                # Large clearing - flying enemies
                if clearing.width > 8 or clearing.height > 8:
                    area_map.add_area(Area(
                        id=f"outdoor_flying_enemy_{area_id_counter}",
                        type=AreaType.FLYING_ENEMY_SPAWN,
                        x=valid_bounds['x'],
                        y=valid_bounds['y'],
                        width=valid_bounds['width'],
                        height=valid_bounds['height'],
                        attributes={"clearing_type": "enemy", "enemy_type": "flying"}
                    ))
                else:
                    # Medium clearing - ground enemies
                    area_map.add_area(Area(
                        id=f"outdoor_ground_enemy_{area_id_counter}",
                        type=AreaType.GROUND_ENEMY_SPAWN,
                        x=valid_bounds['x'],
                        y=valid_bounds['y'],
                        width=valid_bounds['width'],
                        height=valid_bounds['height'],
                        attributes={"clearing_type": "enemy", "enemy_type": "ground"}
                    ))
                area_id_counter += 1

    return area_map


def _add_hybrid_areas(
    area_map: AreaMap,
    level_data: Dict[str, Any],
    terrain_grid: List[List[str]]
) -> AreaMap:
    """Add areas for hybrid levels - combines dungeon and outdoor features"""

    # Start with dungeon areas since hybrid uses BSP structure
    area_map = _add_dungeon_areas(area_map, level_data, terrain_grid)

    # Add outdoor-style enemy areas in larger rooms
    rooms = level_data.get('rooms', [])
    for room in rooms:
        if room.width > 10 or room.height > 10:
            # Get valid bounds that exclude walls
            valid_bounds = _get_valid_area_bounds(room, terrain_grid, len(terrain_grid[0]), len(terrain_grid))
            valid_bounds['y'] = _snap_area_vertically_to_platform(
                valid_bounds['y'], terrain_grid, len(terrain_grid[0]), len(terrain_grid)
            )

            if valid_bounds['width'] >= 3 and valid_bounds['height'] >= 3:
                # Very large room - add flying enemy area
                area_map.add_area(Area(
                    id=f"hybrid_flying_enemy_{len(area_map.areas) + 1}",
                    type=AreaType.FLYING_ENEMY_SPAWN,
                    x=valid_bounds['x'],
                    y=valid_bounds['y'],
                    width=valid_bounds['width'],
                    height=valid_bounds['height'],
                    attributes={"hybrid_type": "open_area"}
                ))

    return area_map


def _ensure_critical_areas(
    area_map: AreaMap,
    level_data: Dict[str, Any],
    terrain_grid: List[List[str]]
) -> AreaMap:
    """
    Ensure all critical area types are present.

    NOTE:
    This must be called AFTER `_dedupe_player_spawn_areas` so that:
    - We do not accidentally stack multiple PLAYER_SPAWN regions.
    - We only create a fallback PLAYER_SPAWN if no such area exists at all.
    """

    height = len(terrain_grid)
    width = len(terrain_grid[0]) if height > 0 else 0

    # Check for missing critical areas (after any normalization/deduping)
    existing_types = {area.type for area in area_map.areas}
    area_id_counter = len(area_map.areas) + 1

    # Ensure PLAYER_SPAWN exists:
    # Only create a fallback when:
    # - There is no PLAYER_SPAWN area at all, and
    # - We have at least one spawn point from generation.
    if AreaType.PLAYER_SPAWN not in existing_types:
        spawn_points = level_data.get("spawn_points", [])
        if spawn_points:
            sx, sy = spawn_points[0]
            # Find nearest walkable area to spawn point
            nearest_walkable = _find_nearest_walkable_area(sx, sy, terrain_grid, width, height)
            if nearest_walkable:
                # Use walkable area bounds
                px = nearest_walkable['x']
                py = nearest_walkable['y']
                pw = nearest_walkable['width']
                ph = nearest_walkable['height']
            else:
                # Fallback: create small area around spawn point
                px = max(0, min(sx - 1, width - 3))
                py = max(0, min(sy - 1, height - 3))
                pw = min(3, width - px)
                ph = min(3, height - py)

            if pw > 0 and ph > 0:
                area_map.add_area(Area(
                    id=f"fallback_player_spawn_{area_id_counter}",
                    type=AreaType.PLAYER_SPAWN,
                    x=px,
                    y=py,
                    width=pw,
                    height=ph,
                    attributes={"fallback": True}
                ))
                area_id_counter += 1

    # Ensure PORTAL_ZONE exists
    if AreaType.PORTAL_ZONE not in existing_types:
        # Place in a corner far from spawn, but ensure it has walkable tiles
        if width > 10 and height > 10:
            # Try different corner positions until we find one with walkable tiles
            corners = [
                (width - 4, height - 4),  # bottom-right
                (1, height - 4),          # bottom-left
                (width - 4, 1),          # top-right
                (1, 1)                    # top-left
            ]

            for cx, cy in corners:
                # Check if this corner area has walkable tiles
                has_walkable = False
                for x in range(cx, min(cx + 3, width)):
                    for y in range(cy, min(cy + 3, height)):
                        if _is_walkable_tile(x, y, terrain_grid):
                            has_walkable = True
                            break
                    if has_walkable:
                        break

                if has_walkable:
                    area_map.add_area(Area(
                        id=f"fallback_portal_zone_{area_id_counter}",
                        type=AreaType.PORTAL_ZONE,
                        x=cx,
                        y=cy,
                        width=3,
                        height=3,
                        attributes={"fallback": True}
                    ))
                    area_id_counter += 1
                    break

    # Ensure at least one enemy spawn area
    if AreaType.GROUND_ENEMY_SPAWN not in existing_types and AreaType.FLYING_ENEMY_SPAWN not in existing_types:
        # Add in center area
        area_map.add_area(Area(
            id=f"fallback_enemy_spawn_{area_id_counter}",
            type=AreaType.GROUND_ENEMY_SPAWN,
            x=width // 2 - 2,
            y=height // 2 - 2,
            width=4,
            height=4,
            attributes={"fallback": True}
        ))

    return area_map


# Helper functions

def _snap_area_vertically_to_platform(y: int, terrain_grid: List[List[str]], width: int, height: int) -> int:
    """
    LEGACY helper (kept for compatibility).

    NOTE:
    We no longer rely on this heuristic alone for merchant/player spawn.
    New logic (_build_supported_band_area) enforces strict support rules.
    """
    if not terrain_grid or y <= 0 or y >= height:
        return y

    try:
        from .terrain_system import TerrainTypeRegistry, TerrainBaseType
    except Exception:
        return y

    platform_like_count = 0
    sample = min(width, 8)
    for x in range(sample):
        tid = terrain_grid[y][x]
        if isinstance(tid, str):
            tag = TerrainTypeRegistry.get_terrain(tid)
            if tag.base_type in (TerrainBaseType.PLATFORM, TerrainBaseType.FLOOR):
                platform_like_count += 1

    if platform_like_count >= max(1, sample // 2) and y + 1 < height:
        return y + 1

    return y


def _build_supported_band_area(
    base_id: str,
    area_type: str,
    bounds: Dict[str, int],
    terrain_grid: List[List[str]],
    min_height: int = 3,
    max_height: int = 6,
) -> Optional[Area]:
    """
    Build an area band where:
    - Every tile row included is fully supported by platform/floor tiles directly beneath
      (no floating).
    - Height is clamped between [min_height, max_height].
    - If overlapping or unsupported rows exist, they are excluded.
    This is used for MERCHANT_AREA and PLAYER_SPAWN style zones so that:
    - The entire highlighted band sits on valid platforms.
    - Player/NPC never appears centered in mid-air.
    """
    from .terrain_system import TerrainTypeRegistry, TerrainBaseType

    if not terrain_grid:
        return None

    height = len(terrain_grid)
    width = len(terrain_grid[0]) if height > 0 else 0

    x0 = max(0, bounds["x"])
    x1 = min(width, bounds["x"] + bounds["width"])
    y0 = max(0, bounds["y"])
    y1 = min(height, bounds["y"] + bounds["height"])

    if x0 >= x1 or y0 >= y1:
        return None

    supported_rows: List[int] = []

    for y in range(y0, y1):
        row_supported = True
        for x in range(x0, x1):
            if not (0 <= x < width and 0 <= y < height):
                row_supported = False
                break

            tid = terrain_grid[y][x]
            tag = TerrainTypeRegistry.get_terrain(tid) if isinstance(tid, str) else None

            # For a row to be part of the band, the tile itself must be walkable/platform-like
            # AND have platform/floor support (itself or directly below).
            is_walkable = False
            if tag and TerrainTypeRegistry.is_platform_like(tag):
                is_walkable = True
            elif tid and "wall" not in str(tid).lower():
                is_walkable = True

            if not is_walkable:
                row_supported = False
                break

            # Check support - platforms and floors are inherently supported
            # For empty space (air), check if there's solid support below
            support_ok = False
            if tag and tag.base_type in (TerrainBaseType.PLATFORM, TerrainBaseType.FLOOR):
                # Platforms and floors support themselves
                support_ok = True
            else:
                # For air tiles or other non-solid tiles, check below
                below_y = y + 1
                if below_y < height:
                    tid_below = terrain_grid[below_y][x]
                    tag_below = TerrainTypeRegistry.get_terrain(tid_below) if isinstance(tid_below, str) else None
                    if tag_below and tag_below.base_type in (TerrainBaseType.PLATFORM, TerrainBaseType.FLOOR, TerrainBaseType.WALL):
                        support_ok = True

            if not support_ok:
                row_supported = False
                break

        if row_supported:
            supported_rows.append(y)

    if not supported_rows:
        return None

    # Build contiguous bands from supported rows and pick the best one (lowest, largest).
    bands: List[Tuple[int, int]] = []
    start = supported_rows[0]
    prev = start
    for y in supported_rows[1:]:
        if y == prev + 1:
            prev = y
        else:
            bands.append((start, prev))
            start = y
            prev = y
    bands.append((start, prev))

    # Pick the lowest band (so visuals hug bottom/platform side).
    band_y0, band_y1 = bands[-1]
    band_height = band_y1 - band_y0 + 1

    # Clamp height - be more flexible to avoid area creation failures
    if band_height > max_height:
        band_y0 = band_y1 - max_height + 1
        band_height = max_height
    elif band_height < min_height:
        # If not enough height, still use the available rows
        # It's better to have a smaller area than no area at all
        band_height = max(1, band_height)

    return Area(
        id=base_id,
        type=area_type,
        x=x0,
        y=band_y0,
        width=x1 - x0,
        height=band_height,
        attributes={},
    )




def _find_walkable_area_bounds(room, terrain_grid: List[List[str]], width: int, height: int) -> Optional[Dict[str, int]]:
    """Find the actual bounds of walkable area within a room"""
    walkable_tiles = []

    # Check all tiles within the room bounds
    for y in range(max(0, room.y), min(room.y + room.height, height)):
        for x in range(max(0, room.x), min(room.x + room.width, width)):
            if y < len(terrain_grid) and x < len(terrain_grid[0]):
                terrain_id = terrain_grid[y][x]
                if isinstance(terrain_id, str):
                    terrain_tag = TerrainTypeRegistry.get_terrain(terrain_id)
                    # Check if it's platform-like (walkable)
                    if terrain_tag and TerrainTypeRegistry.is_platform_like(terrain_tag):
                        walkable_tiles.append((x, y))
                elif terrain_id and "wall" not in str(terrain_id).lower():
                    # Fallback for non-string terrain IDs
                    walkable_tiles.append((x, y))

    if not walkable_tiles:
        return None

    # Find bounding box of walkable tiles
    min_x = min(x for x, y in walkable_tiles)
    max_x = max(x for x, y in walkable_tiles)
    min_y = min(y for x, y in walkable_tiles)
    max_y = max(y for x, y in walkable_tiles)

    return {
        'x': min_x,
        'y': min_y,
        'width': max_x - min_x + 1,
        'height': max_y - min_y + 1
    }


def _is_room_clear(room, terrain_grid: List[List[str]], width: int, height: int) -> bool:
    """Check if room is mostly clear of walls"""
    clear_count = 0
    total_count = 0

    for y in range(max(1, room.y), min(room.y + room.height, height - 1)):
        for x in range(max(1, room.x), min(room.x + room.width, width - 1)):
            total_count += 1
            # Check terrain instead of grid
            if y < len(terrain_grid) and x < len(terrain_grid[0]):
                terrain_id = terrain_grid[y][x]
                if isinstance(terrain_id, str):
                    terrain_tag = TerrainTypeRegistry.get_terrain(terrain_id)
                    # Check if it's not a wall using the terrain system
                    if terrain_tag and terrain_tag.base_type != TerrainBaseType.WALL:
                        clear_count += 1
                elif terrain_id and "wall" not in str(terrain_id).lower():
                    # Fallback for non-string terrain IDs
                    clear_count += 1

    return total_count > 0 and (clear_count / total_count) > 0.7


def _get_valid_area_bounds(room, terrain_grid: List[List[str]], width: int, height: int) -> Dict[str, int]:
    """Get valid bounds for an area that exclude wall tiles"""
    min_x = room.x
    max_x = min(room.x + room.width, width)
    min_y = room.y
    max_y = min(room.y + room.height, height)

    # Find actual bounds that exclude walls
    actual_min_x = max_x
    actual_max_x = min_x
    actual_min_y = max_y
    actual_max_y = min_y

    for y in range(min_y, max_y):
        for x in range(min_x, max_x):
            if y < len(terrain_grid) and x < len(terrain_grid[0]):
                terrain_id = terrain_grid[y][x]
                is_wall = False

                if isinstance(terrain_id, str):
                    terrain_tag = TerrainTypeRegistry.get_terrain(terrain_id)
                    is_wall = terrain_tag and terrain_tag.base_type == TerrainBaseType.WALL
                elif terrain_id and "wall" in str(terrain_id).lower():
                    is_wall = True

                if not is_wall:
                    actual_min_x = min(actual_min_x, x)
                    actual_max_x = max(actual_max_x, x)
                    actual_min_y = min(actual_min_y, y)
                    actual_max_y = max(actual_max_y, y)

    # Ensure we have at least some valid area
    if actual_max_x <= actual_min_x:
        actual_max_x = actual_min_x + 1
    if actual_max_y <= actual_min_y:
        actual_max_y = actual_min_y + 1

    return {
        'x': actual_min_x,
        'y': actual_min_y,
        'width': actual_max_x - actual_min_x,
        'height': actual_max_y - actual_min_y
    }


def _get_area_bounds(tiles: List[Tuple[int, int]]) -> Dict[str, int]:
    """Get bounding box of area tiles"""
    if not tiles:
        return {'x': 0, 'y': 0, 'width': 1, 'height': 1}

    min_x = min(x for x, y in tiles)
    max_x = max(x for x, y in tiles)
    min_y = min(y for x, y in tiles)
    max_y = max(y for x, y in tiles)

    return {
        'x': min_x,
        'y': min_y,
        'width': max_x - min_x + 1,
        'height': max_y - min_y + 1
    }


def _get_area_center(tiles: List[Tuple[int, int]]) -> Tuple[int, int]:
    """Get center point of area tiles"""
    if not tiles:
        return (0, 0)
    cx = sum(x for x, y in tiles) // len(tiles)
    cy = sum(y for x, y in tiles) // len(tiles)
    return (cx, cy)


def _validate_area_coordinates(area_map: AreaMap, terrain_grid: List[List[str]]) -> List[str]:
    """
    Validate that all areas are properly positioned relative to walkable terrain.

    Rules implemented based on design:
    - Every area must:
      - Be inside bounds.
      - Contain at least one walkable/platform-like tile (except for flying areas).
    - Platform support rule (for all logical gameplay areas):
      - For each tile column inside the area where there is any walkable tile,
        ensure there exists at least one PLATFORM/FLOOR tile at or below that
        walkable tile within the same column (no "floating" tiles).
      - This prevents merchant/player/enemy areas from floating in mid-air
        without underlying support tiles.
    - Exceptions:
      - FLYING_ENEMY_SPAWN areas don't require walkable tiles
      - WATER_AREA areas don't require walkable tiles
    """
    issues: List[str] = []

    if not terrain_grid:
        return issues

    height = len(terrain_grid)
    width = len(terrain_grid[0]) if height > 0 else 0

    for area in area_map.areas:
        # Bounds check
        if area.x < 0 or area.y < 0 or area.x + area.width > width or area.y + area.height > height:
            issues.append(
                f"Area {area.id} ({area.type}) is out of bounds: "
                f"({area.x}, {area.y}, {area.width}, {area.height})"
            )
            continue

        # Check if this area type requires walkable tiles
        requires_walkable = area.type not in [AreaType.FLYING_ENEMY_SPAWN, AreaType.WATER_AREA]

        # Track walkable presence and support violations
        has_walkable = False
        floating_columns = 0

        for x in range(area.x, min(area.x + area.width, width)):
            # Scan this column inside the area for walkable tiles
            column_walkable_rows = []
            for y in range(area.y, min(area.y + area.height, height)):
                if y < len(terrain_grid) and x < len(terrain_grid[0]):
                    terrain_id = terrain_grid[y][x]
                    if isinstance(terrain_id, str):
                        terrain_tag = TerrainTypeRegistry.get_terrain(terrain_id)
                        if terrain_tag and TerrainTypeRegistry.is_platform_like(terrain_tag):
                            column_walkable_rows.append(y)
                            has_walkable = True
                    elif terrain_id and "wall" not in str(terrain_id).lower():
                        # Treat non-wall as walkable fallback
                        column_walkable_rows.append(y)
                        has_walkable = True

            if not column_walkable_rows:
                continue  # no walkable usage in this column, skip support check

            # For each walkable row in this column, require a supporting platform-like tile
            # at or below it (no unsupported floating walkable cells).
            column_has_support = False
            for wy in column_walkable_rows:
                support_found = False
                for sy in range(wy, min(area.y + area.height, height)):
                    tid = terrain_grid[sy][x]
                    if isinstance(tid, str):
                        tag = TerrainTypeRegistry.get_terrain(tid)
                        if tag and tag.base_type in (TerrainBaseType.PLATFORM, TerrainBaseType.FLOOR):
                            support_found = True
                            break
                    elif tid and "wall" not in str(tid).lower():
                        # Consider non-wall as valid support fallback
                        support_found = True
                        break
                if support_found:
                    column_has_support = True
                    break

            if not column_has_support:
                floating_columns += 1

        if requires_walkable and not has_walkable:
            issues.append(
                f"Area {area.id} ({area.type}) at ({area.x}, {area.y}) has no walkable tiles"
            )
        elif floating_columns > 0:
            issues.append(
                f"Area {area.id} ({area.type}) has {floating_columns} column(s) with walkable tiles "
                f"that lack underlying platform-like support"
            )

    return issues


def _dedupe_player_spawn_areas(
    area_map: AreaMap,
    level_data: Dict[str, Any],
) -> AreaMap:
    """
    Normalize PLAYER_SPAWN areas to avoid overlapping/stacked bands.

    Rules:
    - If 0 or 1 PLAYER_SPAWN areas exist, do nothing.
    - If multiple exist:
        - Prefer the area containing the primary spawn point (spawn_points[0]) if present.
        - Otherwise prefer the lowest (max y) PLAYER_SPAWN area, which is most likely
          aligned with the actual floor/platform.
        - Remove all other PLAYER_SPAWN areas.
    This keeps the visualization consistent with the single authoritative spawn that
    the gameplay code uses.
    """
    try:
        from .area_system import AreaType  # local import to avoid cycles in some tools
    except Exception:
        return area_map

    player_spawn_areas = [a for a in area_map.areas if a.type == AreaType.PLAYER_SPAWN]
    if len(player_spawn_areas) <= 1:
        return area_map

    spawn_points = level_data.get("spawn_points") or []
    preferred = None

    # 1) Prefer area that contains the primary spawn tile.
    if spawn_points:
        sx, sy = spawn_points[0]
        for area in player_spawn_areas:
            if (area.x <= sx < area.x + area.width) and (area.y <= sy < area.y + area.height):
                preferred = area
                break

    # 2) Otherwise pick the lowest PLAYER_SPAWN area (visually grounded).
    if preferred is None:
        preferred = max(player_spawn_areas, key=lambda a: a.y)

    # Keep only the preferred PLAYER_SPAWN area.
    area_map.areas = [
        a for a in area_map.areas
        if (a.type != AreaType.PLAYER_SPAWN) or (a is preferred)
    ]

    return area_map


def _find_wide_passages(grid: List[List[int]], min_width: int = 3) -> List[Dict[str, int]]:
    """Find wide passages suitable for ground enemies"""
    passages = []
    height = len(grid)
    width = len(grid[0]) if height > 0 else 0

    for y in range(2, height - 2):
        for x in range(2, width - 2):
            # Check if this is a wide area
            if grid[y][x] == 0:
                # Check horizontal width
                h_width = 0
                while x + h_width < width and grid[y][x + h_width] == 0:
                    h_width += 1

                # Check vertical height
                v_height = 0
                while y + v_height < height and grid[y + v_height][x] == 0:
                    v_height += 1

                if h_width >= min_width and v_height >= 2:
                    passages.append({
                        'x': x,
                        'y': y,
                        'width': min(h_width, width - x - 1),
                        'height': min(v_height, height - y - 1)
                    })
                    # Skip ahead
                    x += h_width

    return passages[:5]  # Limit to 5 passages